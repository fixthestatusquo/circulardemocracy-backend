#!/usr/bin/env node

import minimist from 'minimist';
import { hc } from 'hono/client';
import fs from 'fs';

// Load API base URL from OpenAPI spec
function getApiBaseUrl(serverIndex = 0) {
  try {
    // Check environment variable first
    if (process.env.API_URL) {
      return process.env.API_URL;
    }
    
    // Try to load from OpenAPI spec
    if (fs.existsSync('./doc/openapi.json')) {
      const spec = JSON.parse(fs.readFileSync('./doc/openapi.json', 'utf8'));
      
      // Get server URL by index or description from the OpenAPI spec
      if (spec.servers && spec.servers.length > 0) {
        const numericIndex = parseInt(serverIndex, 10);
        if (!isNaN(numericIndex) && spec.servers[numericIndex]) {
          return spec.servers[numericIndex].url;
        }
      
        if (typeof serverIndex === 'string') {
          const server = spec.servers.find(s => 
            s.description?.toLowerCase().includes(serverIndex.toLowerCase()) ||
            s.url.includes(serverIndex)
          );
          if (server) {
            return server.url;
          } else {
            return serverIndex;
          }
        }
       
        console.log("dafuk", serverIndex); 
        // Fallback to first server
        return spec.servers[0].url;
      }
    }
    
    // Fallback to localhost
    return 'http://localhost:3000';
  } catch (error) {
    console.warn('Warning: Could not load API URL from openapi.json, using fallback');
    return 'http://localhost:3000';
  }
}

function listAvailableServers() {
  try {
    if (fs.existsSync('./doc/openapi.json')) {
      const spec = JSON.parse(fs.readFileSync('./doc/openapi.json', 'utf8'));
      
      if (spec.servers && spec.servers.length > 0) {
        console.log('\nAvailable servers:');
        spec.servers.forEach((server, index) => {
          console.log(`  ${index}: ${server.url} ${server.description ? `(${server.description})` : ''}`);
        });
        console.log('\nUse --server=<index> or --server=<description> to select a server\n');
        return;
      }
    }
    
    console.error('No servers found in OpenAPI spec\n');
  } catch (error) {
    console.error('Could not load server information\n');
    
  }
}


async function makeApiCall(endpoint, method = 'GET', params = {}) {
  const token = process.env.SUPABASE_ACCESS_TOKEN || params.token;
  
  // Import your Hono app type - adjust the path as needed
  // import type { AppType } from '../server/app.js';
  
  // For now, we'll use a generic approach without the app type
  // You can replace this with: const client = hc<AppType>(API_BASE_URL);
  const client = hc(API_BASE_URL, {
    headers: {
      ...token && { Authorization: `Bearer ${token}` },
    },
  });

  try {
    if (!endpoint.startsWith ('/api/v1/')) 
       endpoint = 'api/v1/' + endpoint;

    const parts = endpoint.split('/').filter(Boolean);
    let apiCall = client;
    
    for (const part of parts) {
      if (part.startsWith(':')) {
        const paramName = part.slice(1);
        const paramValue = params[paramName];
        if (!paramValue) {
          throw new Error(`Missing path parameter: ${paramName}`);
        }
        apiCall = apiCall[paramValue];
      } else {
        apiCall = apiCall[part];
      }
    }
    
    // Prepare request options
    const options = {};
    
    // Separate path params from query/body params
    const pathParams = {};
    const queryParams = {};
    const bodyParams = {};
    
    Object.entries(params).forEach(([key, value]) => {
      if (endpoint.includes(`:${key}`)) {
        pathParams[key] = value;
      } else if (method === 'GET') {
        queryParams[key] = value;
      } else {
        bodyParams[key] = value;
      }
    });
    
    // Add parameters to options
    if (Object.keys(pathParams).length > 0) {
      options.param = pathParams;
    }
    if (Object.keys(queryParams).length > 0) {
      options.query = queryParams;
    }
    if (Object.keys(bodyParams).length > 0) {
      options.json = bodyParams;
    }
    
    // Make the API call
    const methodName = `$${method.toLowerCase()}`
console.log(apiCall,methodName,options); 
    const response = await apiCall[methodName](options);
    console.log(response);
    if (!response.ok) {
      console.error(`Error ${response.status}: ${response.statusText} ${response.url}`);
      //const errorText = await response.text();
      //console.error(errorText);
      process.exit(1);
    }
    
    const result = await response.json();
    console.log(JSON.stringify(result, null, 2));
    
  } catch (error) {
    console.error('API call failed:', error);
    process.exit(1);
  }
}

// Parse command line arguments with minimist
const argv = minimist(process.argv.slice(2), {
  string: ['method', 'server'],
  alias: {
    m: 'method',
    s: 'server',
    h: 'help',
    v: 'version',
    l: 'list-servers'
  },
  boolean: [
    'post', 'put', 'delete'
  ],
  default: {
    method: 'GET',
    server: 0
  }
});

  [
    'post', 'put', 'delete'
  ].forEach (method => {
    if (argv[method]) {
      argv.method=method.toUpperCase();
    } else {
      delete argv[method];
    }
  });

async function loadEndpointsHelp() {
  try {
    const fs = await import('fs');
    
    // Try to load generated endpoints data
    if (fs.existsSync('./endpoints.json')) {
      const data = fs.readFileSync('./endpoints.json', 'utf8');
      return JSON.parse(data);
    }
    
    // Try to load OpenAPI spec directly
    if (fs.existsSync('./doc/openapi.json')) {
      const spec = JSON.parse(fs.readFileSync('./doc/openapi.json', 'utf8'));
      return generateEndpointsFromSpec(spec);
    }
    
    return null;
  } catch (error) {
    return null;
  }
}

function generateEndpointsFromSpec(spec) {
  const endpoints = [];
  
  Object.entries(spec.paths || {}).forEach(([path, methods]) => {
    Object.entries(methods).forEach(([method, operation]) => {
      const endpoint = {
        path,
        method: method.toUpperCase(),
        summary: operation.summary || '',
        parameters: (operation.parameters || []).map(p => ({
          name: p.name,
          type: p.schema?.type || 'string',
          in: p.in,
          required: p.required || false,
          description: p.description || ''
        }))
      };
      endpoints.push(endpoint);
    });
  });
  
  return endpoints;
}

async function showHelp(filter = '') {
  const endpoints = await loadEndpointsHelp();
  
  if (!endpoints) {
    console.log(`
Usage: ./cli <endpoint> [options]

Arguments:
  <endpoint>    API endpoint path (e.g., campaigns, users/:id)

Options:
  -m, --method     HTTP method (GET, POST, PUT, DELETE) [default: GET]
  -s, --server     Server to use (index or description) [default: 0]
  -l, --list-servers  List available servers from OpenAPI spec
  -h, --help       Show help
  -v, --version    Show version
  --param=val      Any parameter for the API call

Examples:
  ./cli campaigns --name=example --status=active
  ./cli campaigns --server=1 --name=example
  ./cli campaigns --server=prod --name=example
  ./cli campaigns/:id --id=123 --name=updated --method=PUT
  ./cli --list-servers

Note: Run 'node doc-generator.js help' for endpoint-specific help
`);
    return;
  }
  
  console.log('\nAvailable endpoints:\n');
  
  const filtered = filter 
    ? endpoints.filter(e => 
        e.path.includes(filter) || 
        e.method.includes(filter.toUpperCase()) ||
        e.summary.toLowerCase().includes(filter.toLowerCase())
      )
    : endpoints;
  
  filtered.forEach(endpoint => {
    console.log(`--${endpoint.method.toLowerCase()} ${endpoint.path}`);
    if (endpoint.summary) {
      console.log(`  ${endpoint.summary}`);
    }
    
    if (endpoint.parameters.length > 0) {
      console.log('  Parameters:');
      endpoint.parameters.forEach(param => {
        const req = param.required ? '(required)' : '(optional)';
        console.log(`    --${param.name} (${param.type}, ${param.in}) ${req}`);
      });
    }
    
    console.log('');
  });
}

if (argv['list-servers']) {
  listAvailableServers();
  process.exit(0);
}

if (argv.help) {
  listAvailableServers();
  await showHelp(argv._[0]);
  process.exit(0);
}

if (argv.version) {
  console.log('1.0.0');
  process.exit(0);
}

// Get API base URL with server selection
const API_BASE_URL = getApiBaseUrl(argv.server);

console.log(argv._);
const endpoint = argv._[0];

if (!endpoint) {
  console.error('Error: Missing endpoint argument');
  showHelp();
  process.exit(1);
}

// Extract parameters (everything except method, help, version, server, list-servers and the endpoint)
const { _, method, help, version, server, 'list-servers': listServers, ...params } = argv;

// Convert string values to appropriate types
Object.keys(params).forEach(key => {
  const value = params[key];
  if (typeof value === 'string') {
    if (value === 'true') {
      params[key] = true;
    } else if (value === 'false') {
      params[key] = false;
    } else if (!isNaN(value) && !isNaN(parseFloat(value)) && value !== '') {
      params[key] = parseFloat(value);
    }
  }
});

// Make the API call
makeApiCall(endpoint, method.toUpperCase(), params);
